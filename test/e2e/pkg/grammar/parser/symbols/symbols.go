
// Package symbols is generated by gogll. Do not edit.
package symbols

import(
	"bytes"
	"fmt"
)

type Symbol interface{
	isSymbol()
	IsNonTerminal() bool
	String() string
}

func (NT) isSymbol() {}
func (T) isSymbol() {}

// NT is the type of non-terminals symbols
type NT int
const( 
	NT_ApplyChunk NT = iota
	NT_ApplyChunks 
	NT_CleanStart 
	NT_Commit 
	NT_ConsensusExec 
	NT_ConsensusHeight 
	NT_ConsensusHeights 
	NT_ConsensusRound 
	NT_ConsensusRounds 
	NT_Decide 
	NT_InitChain 
	NT_NonProposer 
	NT_OfferSnapshot 
	NT_PrepareProposal 
	NT_ProcessProposal 
	NT_Proposer 
	NT_Recovery 
	NT_Start 
	NT_StateSync 
	NT_StateSyncAttempt 
	NT_StateSyncAttempts 
	NT_SuccessSync 
)

// T is the type of terminals symbols
type T int
const( 
	T_0 T = iota // <ApplyChunk> 
	T_1  // <Commit> 
	T_2  // <FinalizeBlock> 
	T_3  // <InitChain> 
	T_4  // <OfferSnapshot> 
	T_5  // <PrepareProposal> 
	T_6  // <ProcessProposal> 
)

type Symbols []Symbol

func (ss Symbols) Equal(ss1 Symbols) bool {
	if len(ss) != len(ss1) {
		return false
	}
	for i, s := range ss {
		if s.String() != ss1[i].String() {
			return false
		}
	}
	return true
}

func (ss Symbols) String() string {
	w := new(bytes.Buffer)
	for i, s := range ss {
		if i > 0 {
			fmt.Fprint(w, " ")
		}
		fmt.Fprintf(w, "%s", s)
	}
	return w.String()
}

func (ss Symbols) Strings() []string {
	strs := make([]string, len(ss))
	for i, s := range ss {
		strs[i] = s.String()
	}
	return strs
}

func (NT) IsNonTerminal() bool {
	return true
}

func (T) IsNonTerminal() bool {
	return false
}

func (nt NT) String() string {
	return ntToString[nt]
}

func (t T) String() string {
	return tToString[t]
}

// IsNT returns true iff sym is a non-terminal symbol of the grammar
func IsNT(sym string) bool {
	_, exist := stringNT[sym]
	return exist
}

// ToNT returns the NT value of sym or panics if sym is not a non-terminal of the grammar
func ToNT(sym string) NT {
	nt, exist := stringNT[sym]
	if !exist {
		panic(fmt.Sprintf("No NT: %s", sym))
	}
	return nt
}

var ntToString = []string { 
	"ApplyChunk", /* NT_ApplyChunk */
	"ApplyChunks", /* NT_ApplyChunks */
	"CleanStart", /* NT_CleanStart */
	"Commit", /* NT_Commit */
	"ConsensusExec", /* NT_ConsensusExec */
	"ConsensusHeight", /* NT_ConsensusHeight */
	"ConsensusHeights", /* NT_ConsensusHeights */
	"ConsensusRound", /* NT_ConsensusRound */
	"ConsensusRounds", /* NT_ConsensusRounds */
	"Decide", /* NT_Decide */
	"InitChain", /* NT_InitChain */
	"NonProposer", /* NT_NonProposer */
	"OfferSnapshot", /* NT_OfferSnapshot */
	"PrepareProposal", /* NT_PrepareProposal */
	"ProcessProposal", /* NT_ProcessProposal */
	"Proposer", /* NT_Proposer */
	"Recovery", /* NT_Recovery */
	"Start", /* NT_Start */
	"StateSync", /* NT_StateSync */
	"StateSyncAttempt", /* NT_StateSyncAttempt */
	"StateSyncAttempts", /* NT_StateSyncAttempts */
	"SuccessSync", /* NT_SuccessSync */ 
}

var tToString = []string { 
	"<ApplyChunk>", /* T_0 */
	"<Commit>", /* T_1 */
	"<FinalizeBlock>", /* T_2 */
	"<InitChain>", /* T_3 */
	"<OfferSnapshot>", /* T_4 */
	"<PrepareProposal>", /* T_5 */
	"<ProcessProposal>", /* T_6 */ 
}

var stringNT = map[string]NT{ 
	"ApplyChunk":NT_ApplyChunk,
	"ApplyChunks":NT_ApplyChunks,
	"CleanStart":NT_CleanStart,
	"Commit":NT_Commit,
	"ConsensusExec":NT_ConsensusExec,
	"ConsensusHeight":NT_ConsensusHeight,
	"ConsensusHeights":NT_ConsensusHeights,
	"ConsensusRound":NT_ConsensusRound,
	"ConsensusRounds":NT_ConsensusRounds,
	"Decide":NT_Decide,
	"InitChain":NT_InitChain,
	"NonProposer":NT_NonProposer,
	"OfferSnapshot":NT_OfferSnapshot,
	"PrepareProposal":NT_PrepareProposal,
	"ProcessProposal":NT_ProcessProposal,
	"Proposer":NT_Proposer,
	"Recovery":NT_Recovery,
	"Start":NT_Start,
	"StateSync":NT_StateSync,
	"StateSyncAttempt":NT_StateSyncAttempt,
	"StateSyncAttempts":NT_StateSyncAttempts,
	"SuccessSync":NT_SuccessSync,
}
